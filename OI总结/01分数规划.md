# $01$分数规划 

## 大致的问题：
求出：
$$
\frac{\Sigma_{i=1}^{n} a_i}{\Sigma_{i=1}^{n} b_i}(Min | Max)
$$

### 经典例题：

有 $n$ 杯盐水，每次给定两个值:$m_i$ 和 $y_i$

浓度定义：盐的总重量 / 盐水的总重量

$m_i$表示盐水的总量 

求在这$n$杯盐水选$k$杯水所能获取的最大浓度（即盐的总重量 / 盐水的总重量的最大值）

问题转化：

求
$$
\frac{\Sigma_{j=1}^{k} y_j}{\Sigma_{j-1}^{k} m_j} (min)
$$

### 求解过程：

暴力解法大致就是在 $n$ 杯里面选 $k$ 杯水，复杂度爆炸暂时不考虑

#### 对于正解：
考虑二分答案 

> 二分最大浓度

如果 $\exist$ $x$ 使得$\frac{\Sigma_{j=1}^{k} y_j}{\Sigma_{j-1}^{k} m_j} $ $\geq$ $x$ 说明 $x$不是最大浓度

进一步化简可以得到：

如果当前二分 $mid=X$

如果$\Sigma_{j=1}^{k} m_j $ $-$ $X * \Sigma_{j=1}^{k} y_j$ $\geq$ $0$

证明比最大浓度小

便使$l=mid$

$<0$的话，就让$r=mid$

那么整个二分答案的框架算大致出来了

问题就在于如何选择 $m_j$ 与 $y_j$

> 由$\Sigma_{j=1}^{k} m_j $ $-$ $X * \Sigma_{j=1}^{k} y_j$ $\geq$ $0$这个式子可以很容易地推出：

可以定义一个 $c_i = m_i - X*y_i$ 因为是 $n$ 个选择 $k$ 个，所以将$c_i$ 从大到小排序，选择前$k$大的加起来，如果$\geq0$返回$true$ 否则返回$false$（这个结论很好证明，之后的判定都会用到相关思路）



### 拓展问题：

[CF489E Hiking](https://www.luogu.com.cn/problem/CF489E)

题意：

有 $n$ 个一个旅行者正在计划沿着河水进行一场水上远足。经过探测，他已经探明了这条河上适合晚上休息的 $n$ 个地点，记录了这些地点与出发点的距离。

上述的每一个地点都有一个美丽度。也就是说，对于第 $i$ 个地点，它和起点的距离为 $x_i$ ，它的美丽度为 $b_i$。

上述的每一个地点都在出发点的下游，且这个旅行者在旅行的时候只会顺流而下。

简言之，我们可以把河流看成一个数轴，出发点的坐标是0，第 $i$ 个地点的坐标是 $x_i$ 。旅行者只会沿正方向前进。

这个旅行者对他一天的前进距离，设定了一个基准值 $l$ ，如果他某天的所前进的距离大于或小于了这个基准值，都会使他疲劳。假设他一天走了 $r_i$ 的距离，那么他产生的疲劳值为 $\sqrt{|r_j-l|}$ ，他整个旅程的总疲劳值为每一天的疲劳值之和。

显然，这个旅行者晚上需要休息，所以必须到达一个休息地点才能结束一天的行程，并在这个地点过夜。类似于上面的定义，假设他当天晚上在第 $i$ 个地点休息，那么他当天的舒适度为这个地点的美丽度，即 $b_i$ 。他整个旅程的总舒适度是每一天（包括最后一天）的舒适度之和。

现在他希望你帮助他规划旅游路线，确定出每一天在哪个地点休息，他对旅游的天数没有要求，但是要求最后一天必须在第 $n$ 个地点休息。他希望你的这个规划足够合理，使得这次旅行的**总疲劳值除以总舒适度**的结果最小化。

$1 \leq n \leq 10^3$,$1 \leq l \leq 10^5$,$1 \leq x_i,b_i \leq 10^6$

>使得这次旅行的**总疲劳值除以总舒适度**的结果最小化。

一看到这句话：很容易想到01分数规划

看一看数据范围：

二分答案的复杂度为($log$ $V$)（也就是 $log$ 最大值）

算下来的话答案判定的复杂度是可以支持$O(n^2)$的

所以我考虑了递推或者说$DP$?

在二分答案的思路下：

设需要判定的$mid=x$

我们设一个数组 $f[i][j]$ 为$i$ 到 $j$ 的代价

我们珂以$O(n^2)$预处理出

```cpp
for(int i=1;i<=n;++i){
	for(int j=0;j<i;++j){
		f[i][j]=sqrt(fabs(a[i].x-a[j].x-l))-x*a[i].b;
	}
}
```

那么DP转移也珂以$O(n^2)$ 的求出（珂以在转移的同时处理$f数组$）：

```cpp
for(int i=1;i<=n;++i){
		for(int j=0;j<i;++j){
			f[i][j]=sqrt(fabs(a[i].x-a[j].x-l))-x*a[i].b;
			if(dp[i]>f[i][j]+dp[j]){mypath[i]=j;dp[i]=f[i][j]+dp[j];}
		}
	}

```

整个二分答案的$check$函数的Code:

```cpp
const int INF=0x3f3f3f3f;
inline bool check(double x){
	for(int i=1;i<=n;++i){dp[i]=INF;}
	dp[0]=0;
	for(int i=1;i<=n;++i){
		for(int j=0;j<i;++j){
			f[i][j]=sqrt(fabs(a[i].x-a[j].x-l))-x*a[i].b;
			if(dp[i]>f[i][j]+dp[j]){mypath[i]=j;dp[i]=f[i][j]+dp[j];}
		}
	}
	return dp[n]<=0;
}
```





